PURPOSE OF THIS DOCUMENT

This document contains a bit of "design" of our parsers, reasons for why
they are so messy and a warning for anyone who wants to reorganize it.

REQUIREMENTS

We currently need 2 parsers in LoXiM. LoXiM is written in C++, so we had to
provide a solution which would enable us to:
- have 2 parsers (not for free in bison)
- call C++ code in it (which at first suggests using bison's C++ generating
  feature)
- call it reentrantly (a global parser is a BAD solution)
- fit in our namespaces
- have to code somewhat portable
- build the parser using autotools
- interface with some lexer which should fulfill similar requirements


HISTORY

It turned out not be that easy. In the early days of LoXiM we had one global
parser. It was obviously wrong. The lexer wasn't much better. The first attempt
to achieve the above rquirements was to force flex and bison to generate C++
code. I did that and it worked, however, not for long. It had much hacking in
it, so when new version of bison appeared - it stopped working. Moreover, the
solution was hard to integrate with autotools because of a probable bug (or a
lack of a feature, doesn't matter, anyway it didn't work) in autotools being
unable to handle >2 files generated by bison (bison's output, when generating
to C++ is currently 5 files). I forced it to run with some more hacks, however,
the new versions of bison were still affected.

There were 3 options:
-generate a parser to C (much better integration with autotools (working!),
 better support and so on)
 However, this had shortcommings: it would have been hard to have 2 parsers, it
 would have violated our namespaces and the parser would have had to be
 rewritten to C.
-add another hacks to make it work with autotools and new bison
 This would probably have been a temporary solution. (until the next version of
 bison)
-change the parser generator
 This would have added even more dependencies to our project, which, taking
 under consideration limited number of active developers, would have made LoXiM
 not portable and harder to maintain. Keep in mind, that despite poor C++
 support, bison is a mature and efficent parser generator, which is what we
 desire.

Finally, I chose the fourth:
Tell (cheat :)) bison that we were generating C code, having C++ in it.

This approach doesn't fulfill the requirements about multpile parsers and
namespaces, so I used a dirty hack:
The generated files are not to be used directly, there are some C++ wrappers
which brutally include the generated files inside a proper namespace.
This way we do not have to even use bison, yacc is enough (prooven on NetBSD).

Forunatelly, things with flex were much better. Despite having to mess a lot
with nasty macros (which is far from elegant), we use it to generate C++ish,
working code directly.


THINGS YOU REALLY NEED TO KNOW (if you're messing with the parsers):

(based on the AdminParser, but you can use sed to get the manual for
QueryParser ;))


