#include <iostream>
#include <fstream>
#include <sstream>
#include <errno.h>
#include <stdexcept>
#include <vector>
#include <map>
#include <algorithm>

#include <xercesc/parsers/XercesDOMParser.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/sax/HandlerBase.hpp>
#include <xercesc/util/XMLString.hpp>
#include <xercesc/util/PlatformUtils.hpp>


using namespace std;
using namespace xercesc;

string target_dir;

void usage(char *binary)
{
	cout << "usage: " << binary << " <xml> <target directory>" << endl;
	exit(EINVAL);
}

#define notice "/* This file is generated by lw_protogen. DO NOT EDIT.*/"
#define notice2 "# This file is generated by lw_protogen. DO NOT EDIT."

namespace xercesc_3_0 {
	class MyErrorHandler : public ErrorHandler {

		virtual void warning(const SAXParseException& exc)
		{
			throw exc;
		}

		virtual void error(const SAXParseException& exc)
		{
			throw exc;
		}

		virtual void fatalError(const SAXParseException& exc)
		{
			throw exc;
		}

		virtual void resetErrors()
		{
		}
	};


	string X2S(const XMLCh *xs)
	{
		char *cs = XMLString::transcode(xs);
		string s(cs);
		XMLString::release(&cs);
		return s;
	}

	class XMLStr{
		private:
		XMLCh *ch;
		public:
		XMLStr(const string &s)
		{
			ch = XMLString::transcode(s.c_str());
		}

		XMLStr(const XMLStr& s2)
		{
			ch = XMLString::replicate(s2.ch);
		}

		XMLStr &operator=(const XMLStr &s2)
		{
			XMLCh *ch2 = XMLString::replicate(s2.ch);
			XMLString::release(&ch);
			ch = ch2;
		}

		const XMLCh *val()
		{
			return ch;
		}

		~XMLStr()
		{
			XMLString::release(&ch);
		}
	};

	inline XMLStr S2X(const string &s)
	{
		return XMLStr(s);
	}

}


class Field{
	public:
		string name;
		string type;
		string value;
		string object_ref;
		string object_ref_id;
		//used only if the type is package-map
		string type_holder;
		int size;
		bool nullable;
	
		Field(DOMElement &el):
			name(X2S(el.getAttribute(S2X("name").val()))),
			type(X2S(el.getAttribute(S2X("type").val()))),
			value(X2S(el.getAttribute(S2X("value").val()))),
			object_ref(X2S(el.getAttribute(S2X("object-ref").val()))),
			object_ref_id(X2S(el.getAttribute(S2X("object-ref-id").val()))),
			size(atoi(X2S(el.getAttribute(S2X("size").val())).c_str())),
			nullable((X2S(el.getAttribute(S2X("nullable").val()))).compare("false"))
		{
		}
		
};


class field_by_name_finder{
	string name;
	public:
		field_by_name_finder(const string &name) : name(name) {};
		bool operator()(const Field &f)
		{
			return !name.compare(f.name);
		}
};

class Package{


	public:
		
		string name;
		int id;
		string s_id;
		string extends_group;
		string extends_package;
		vector<Field> fields;
		bool flattened;
		
		Package(DOMElement &el):
			name(X2S(el.getAttribute(S2X("name").val()))),
			id(atoi(X2S(el.getAttribute(S2X("id-value").val())).c_str())),
			s_id(X2S(el.getAttribute(S2X("id-value").val()))),
			extends_group(X2S(el.getAttribute(S2X("extends-group").val()))),
			extends_package(X2S(el.getAttribute(S2X("extends-packet").val()))),
			flattened(false)
		{
			DOMNodeList &lst = *el.getChildNodes();
			for (int i = 0; i < lst.getLength(); ++i){
				DOMNode &n = *lst.item(i);
				if (n.getNodeType() == DOMNode::ELEMENT_NODE){
					fields.push_back(Field(*dynamic_cast<DOMElement*>(&n)));
				}
			}
			vector<Field> fields2;
			if (fields.size() > 0 && !fields[0].type.compare("package-map"))
				throw runtime_error("this version of protocol generator needs to have package-map preceded by it's type");
			for (vector<Field>::iterator field = fields.begin(); field != fields.end(); ++field){
				if ((field+1) != fields.end() && !(field+1)->type.compare("package-map")){
					if (field->name.compare((field+1)->object_ref_id))
						throw runtime_error("this version of protocol generator needs to have package-map preceded by it's type");
					if (field->type.compare("varuint"))
						throw runtime_error("package-map is assumed to be preceded with a type of varuint");
				} else
					fields2.push_back(*field);
			}
			fields.swap(fields2);
			
		}

		Package(const Package &p2):
			name(p2.name),
			id(p2.id),
			extends_group(p2.extends_group),
			extends_package(p2.extends_package),
			fields(p2.fields),
			flattened(p2.flattened)
		{
		}
		
		class package_group_finder{
			string name;
			public:
				package_group_finder(const string &name) : name(name) {};
				bool operator()(const pair<string, map<string, Package> > &p)
				{
					return !p.first.compare(name);
				}
				
		};

		void flatten(vector<pair<string, map<string, Package> > > &package_groups) 
		{
			if (flattened)
				return;
			vector<Field> fields2;
			for (vector<Field>::iterator field = fields.begin(); field != fields.end(); ++field){
				if (!field->type.compare("package")){
					vector<pair<string, map<string,
						Package> > >::iterator pg =
							find_if(package_groups.begin(),
									package_groups.end(),
									package_group_finder(field->object_ref));
					if (pg == package_groups.end())
						throw runtime_error("no package group" + field->object_ref);
					map<string, Package>::iterator pi = pg->second.find(field->object_ref_id);
					if (pi == pg->second.end())
						throw runtime_error("no package " + field->object_ref_id);
					Package &p = pi->second;
					p.flatten(package_groups);
					fields2.insert(fields2.end(), p.fields.begin(), p.fields.end());
				} else {
					fields2.push_back(*field);
				}
			}
			fields.swap(fields2);
			flattened = true;
		}
};

class EnumItem{
	public:
		string name;
		string value;
		EnumItem(DOMElement &el):
			name(X2S(el.getAttribute(S2X("name").val()))),
			value(X2S(el.getAttribute(S2X("value").val())).c_str())
		{
		}

		EnumItem(const EnumItem &e2):
			name(e2.name),
			value(e2.value)
		{
		}
};

class Enum{
	public:
		string name;
		string type;
		vector<EnumItem> items;
		Enum(DOMElement &el):
			name(X2S(el.getAttribute(S2X("name").val()))),
			type(X2S(el.getAttribute(S2X("as-type").val())))
		{
			DOMNodeList &lst = *el.getChildNodes();
			for (int i = 0; i < lst.getLength(); ++i){
				DOMNode &n = *lst.item(i);
				if (n.getNodeType() == DOMNode::ELEMENT_NODE){
					items.push_back(EnumItem(*dynamic_cast<DOMElement*>(&n)));
				}
			}
		}
};

string make_class_name(const string &s)
{
	string res;
	bool next_capital = true;
	bool nc_burst = false;
	for (int i = 0; i < s.length(); ++i){
		if (s[i] == '_'){
			next_capital = true;
			nc_burst = true;
		} else
			if (next_capital){
				res += toupper(s[i]);
				next_capital = false;
			} else {
				if (nc_burst && (i+1 < s.length()) && s[i+1] == '_')
					res += toupper(s[i]);
				else
					res += s[i];
				nc_burst = false;
			}
	}
	return res;
}

string first_upper(const string &s)
{
	string res(s);
	if (s.length())
		res[0] = toupper(s[0]);
	return res;
}

string make_define_name(const string &s)
{
	string res;
	bool prev_capital = true;
	for (int i = 0; i < s.length(); i++){
		if (isupper(s[i] && !prev_capital))
			res += "_";
		res += toupper(s[i]);
		prev_capital = isupper(s[i]);
	}
	return res;
}

class enum_by_name_finder{
	string name;
	public:
	enum_by_name_finder(const string &name) : name(name) {};
	bool operator()(const Enum &en)
	{
		return !en.name.compare(name);
	}
};


string to_C_type(const string &t, const vector<Enum> &enums, const Field &f)
{
	//one of [us]int{8,16,32,64}
	if (t.length() > 2 && t[1] == 'i'){
		if (t[0] == 'u')
			return t + "_t";
		else
			return t.substr(1) + "_t";
	}
	if (!t.compare("varuint"))
		return "VarUint";
	if (!t.compare("bool"))
		return "bool";
	if (!t.compare("double"))
		return "double";
	if (!t.compare("bytes") || !t.compare("sstring") || !t.compare("string"))
		return "std::auto_ptr<ByteBuffer>";
	if (!t.compare("package")) 
		throw runtime_error("trying to generate type for meta-type (package)");
	if (!t.compare("package-map"))
		return "std::auto_ptr<Package>";
	if (!t.compare("enum-map") || !t.compare("enum")){
		vector<Enum>::const_iterator i = find_if(enums.begin(), enums.end(), enum_by_name_finder(f.object_ref));
		if (i == enums.end())
			throw runtime_error("no such enum as " + f.object_ref);
		return to_C_type(i->type, enums, f);
	}
	throw runtime_error("internal error");
}

string to_raw_C_type(const string &t)
{
	if (!t.compare("package-map"))
		return "Package";
	return "ByteBuffer";
}


string to_stream_type(const string &t, const vector<Enum> &enums, const Field &f)
{
	//one of [us]int{8,16,32,64}
	if (t.length() > 2 && t[1] == 'i'){
		if (t[0] == 'u')
			return t;
		else
			return t.substr(1);
	}
	if (!t.compare("varuint"))
		return "varuint";
	if (!t.compare("bool"))
		return "bool";
	if (!t.compare("double"))
		return "double";
	if (!t.compare("bytes"))
		return ("bytes");
	if (!t.compare("sstring") || !t.compare("string"))
		return "string";
	if (!t.compare("package"))
		throw runtime_error("trying to generate code for meta package");
	if (!t.compare("package-map"))
		throw runtime_error("trying to generate code for package map directly");
	if (!t.compare("enum-map") || !t.compare("enum")){
		vector<Enum>::const_iterator i = find_if(enums.begin(), enums.end(), enum_by_name_finder(f.object_ref));
		if (i == enums.end())
			throw runtime_error("no such enum as " + f.object_ref);
		return to_stream_type(i->type, enums, f);
	}
	throw runtime_error("internal error");
}

bool is_object(const string& type)
{
	return (!type.compare("bytes") || !type.compare("sstring") || !type.compare("string")) || !type.compare("package-map");
}


map<string, Package> handle_packages(DOMElement &packages)
{
	map<string, Package> res;
	DOMNodeList &lst = *packages.getChildNodes();
	for (int i = 0; i < lst.getLength(); ++i){
		DOMNode &n = *lst.item(i);
		if (n.getNodeType() == DOMNode::ELEMENT_NODE){
			Package p(*dynamic_cast<DOMElement*>(&n));
			/*packages with no id and no fields don't make any sense*/
			/*except for inheritance which we don't implement anyway*/
			if (p.s_id.size() != 0 || p.fields.size() != 0)
				res.insert(make_pair(p.name, p));
		}
	}
	return res;
}

pair<string, map<string, Package> >  handle_package_group(DOMElement &group)
{
	string name = X2S(group.getAttribute(S2X("name").val()));
	
	DOMNodeList &lst = *group.getChildNodes();
	for (int i = 0; i < lst.getLength(); ++i){
		DOMNode &n = *lst.item(i);
		if (n.getNodeType() == DOMNode::ELEMENT_NODE)
			return make_pair(name, handle_packages(*dynamic_cast<DOMElement*>(&n)));
	}
}

vector<pair<string, map<string, Package> > > handle_package_groups(DOMElement &groups)
{
	vector<pair<string, map<string, Package> > > res;
	DOMNodeList &lst = *groups.getChildNodes();
	for (int i = 0; i < lst.getLength(); ++i){
		DOMNode &n = *lst.item(i);
		if (n.getNodeType() == DOMNode::ELEMENT_NODE)
			res.push_back(handle_package_group(*dynamic_cast<DOMElement*>(&n)));
	}
	return res;
}

vector<Enum> handle_enums(DOMElement &el)
{
	vector<Enum> res;
	DOMNodeList &lst = *el.getChildNodes();
	for (int i = 0; i < lst.getLength(); ++i){
		DOMNode &n = *lst.item(i);
		if (n.getNodeType() == DOMNode::ELEMENT_NODE)
			res.push_back(Enum(*dynamic_cast<DOMElement*>(&n)));
	}
	return res;
}

string get_ctor_sig(const Package &p, const vector<Enum> &enums)
{
	stringstream ss;
	ss << make_class_name(p.name) << "Package" << "(";
	for (vector<Field>::const_iterator i = p.fields.begin(); i != p.fields.end(); ++i){
		ss << to_C_type(i->type, enums, *i) << " " << i->name;
		if ((i + 1) != p.fields.end())
			ss << ", ";
	}
	ss << ")";
	return ss.str();
}


string get_size(const string &name, const string &type, const vector<Enum> &enums, const string &object_ref)
{
	if (!type.compare("uint8"))
		return "1";
	if (!type.compare("uint16"))
		return "2";
	if (!type.compare("uint32"))
		return "4";
	if (!type.compare("uint64"))
		return "8";
	if (!type.compare("sint8"))
		return "1";
	if (!type.compare("sint16"))
		return "2";
	if (!type.compare("sint32"))
		return "4";
	if (!type.compare("sint64"))
		return "8";
	if (!type.compare("varuint"))
		return "DataStream::get_varuint_size(" + name + ")";
	if (!type.compare("bool"))
		return "1";
	if (!type.compare("double"))
		return "8";
	if (!type.compare("bytes"))
		return name + "->get_ser_size()";

	if (!type.compare("sstring"))
		return name + "->get_ser_size()";
	if (!type.compare("string"))
		return name + "->get_ser_size()";
	if (!type.compare("enum") || !type.compare("enum-map")){
		vector<Enum>::const_iterator i = find_if(enums.begin(), enums.end(), enum_by_name_finder(object_ref));
		if (i == enums.end())
			throw runtime_error("no such enum as " + object_ref);
		return get_size(name, i->type, enums, object_ref);
	}

	if (!type.compare("package"))
		throw runtime_error("trying to dereference package meta type");
	if (!type.compare("package-map"))
		return name + "->get_ser_size() + DataStream::get_varuint_size(VarUint(" + name + "->get_type(), false))";
	throw runtime_error("internal error");
}

string get_to_string_impl(const string &name, const string &t)
{

	//one of [us]int{16,32,64}
	if (!t.compare("uint8") || !t.compare("sint8"))
		return "((int)" + name + ")";
	if ((t.length() > 2 && t[1] == 'i') || !t.compare("bool") || !t.compare("double")){
		return name;
	}
	if (!t.compare("varuint"))
		return "(" + name + ".is_null()?0:" + name + ".get_val())";
	if (!t.compare("bytes"))
		return "\"byte stream (size \" << " + name + "->get_size() << \")\" ";
	if (!t.compare("sstring") || !t.compare("string"))
		return name + "->get_const_data()";
	if (!t.compare("package"))
		throw runtime_error("trying to reference a meta-package");
	if (!t.compare("package-map"))
		return name + "->to_string()";
	if (!t.compare("enum-map") || !t.compare("enum"))
		return name;
	throw runtime_error("internal error");
}

string make_upper(const string &s)
{
	string res;
	for (int i = 0; i < s.length(); i++){
		if (toupper(s[i]) == EOF)
			res += s[i];
		else
			res += toupper(s[i]);
	}
	return res;
}


void generate_package_headers(const vector<pair<string, map<string, Package> > > &package_groups, const vector<Enum> &enums)
{
	for (vector<pair<string, map<string, Package> > >::const_iterator i = package_groups.begin(); i != package_groups.end(); ++i){
		cout << "Generating headers for package group " << i->first << endl;
		for (map<string, Package>::const_iterator j = i->second.begin(); j != i->second.end(); ++j){
			cout << " Generating header for package " << j->first << " with " << j->second.fields.size() << " fields" << endl;

			string cls = make_class_name(j->first) + "Package";
			string f_name = target_dir + "/Packages/" + first_upper(i->first) + "/" + cls + ".h";
			ofstream header((f_name).c_str());
			if (!header.is_open()){
				cout << "   !!!Processiong package " + j->second.name + " failed (couldn't create files)" << endl;
				exit(1);
			}
			string guard = "PROTOCOL_" + make_define_name(j->second.name) + "_PACKAGE_H";
			header << "#ifndef " << guard << endl;
			header << "#define " << guard << endl << endl;
			header << notice << endl;
			header << "#include <string>" << endl;
			header << "#include <memory>" << endl;
			header << "#include <Protocol/Packages/Package.h>" << endl;
			if (j->second.extends_package.size()){
				header << "#include <Protocol/Packages/" << first_upper(i->first) << "/" << make_class_name(j->second.extends_package) << "Package.h>" << endl;
			}
			header << "#include <Protocol/ByteBuffer.h>" << endl << endl;

			header << "namespace Protocol {" << endl;
			if (j->second.extends_package.size())
				header << "\tclass " << cls << " : public " << make_class_name(j->second.extends_package) << "Package {" << endl;
			else
				header << "\tclass " << cls << " : public Package {" << endl;

			header << "\t\tprivate:" << endl;

			for (vector<Field>::const_iterator k = j->second.fields.begin(); k != j->second.fields.end(); ++k){
				header << "\t\t\t" << to_C_type(k->type, enums, *k) << " " << k->name << ";" << endl;
			}
			header << "\t\tpublic:" << endl;
			header << "\t\t\t" << cls << "(const sigset_t &mask, const bool &cancel, size_t &length, DataStream &stream);" << endl;
			header << "\t\t\t" << get_ctor_sig(j->second, enums) << ";" << endl << endl;
			
			if (!j->second.extends_package.size())
				header << "\t\t\tvoid serialize(const sigset_t &mask, const bool& cancel, DataStream &stream, bool with_header = true) const;" << endl; 
			header << "\t\t\tuint8_t get_type() const;" << endl;
			if (!j->second.extends_package.size()){
				header << "\t\t\tstd::string to_string() const;" << endl;
				header << "\t\t\tsize_t get_ser_size() const;" << endl;
				for (vector<Field>::const_iterator k = j->second.fields.begin(); k != j->second.fields.end(); ++k){
					if (is_object(k->type))
						header << "\t\t\tconst " << to_raw_C_type(k->type) << " &get_val_" << k->name << "() const;" << endl;
					else
						header << "\t\t\t" << to_C_type(k->type, enums, *k) << " get_val_" << k->name << "() const;" << endl;
				}
			}
			header << "\t};" << endl;
			header << "}" << endl;
			header << "#endif" << endl;
		}
	}
}


void generate_package_implementations(const vector<pair<string, map<string, Package> > > &package_groups, const vector<Enum> &enums)
{
	for (vector<pair<string, map<string, Package> > >::const_iterator i = package_groups.begin(); i != package_groups.end(); ++i){
		cout << "Generating implementations for package group " << i->first << endl;
		for (map<string, Package>::const_iterator j = i->second.begin(); j != i->second.end(); ++j){
			cout << " Generating implementation for package " << j->first << " with " << j->second.fields.size() << " fields" << endl;

			string cls = make_class_name(j->first) + "Package";
			string f_name = target_dir + "/Packages/" + first_upper(i->first) + "/" + cls + ".cpp";
			ofstream impl((f_name).c_str());
			if (!impl.is_open()){
				cout << "   !!!Processiong package " + j->second.name + " failed (couldn't create files)" << endl;
				exit(1);
			}
			impl << notice << endl;
			impl << "#include <string>" << endl;
			impl << "#include <sstream>" << endl;
			for (vector<pair<string, map<string, Package> > >::const_iterator h = package_groups.begin(); h != package_groups.end(); ++h){
				impl << "#include <Protocol/Enums/" << first_upper(h->first) << "Packages.h>" << endl;
				impl << "#include <Protocol/" << first_upper(h->first) << "PackageFactory.h>" << endl;
			}
			impl << "#include <Protocol/Enums/Packages.h>" << endl;
			if (i->first.size() == 0)
				impl << "#include <Protocol/Packages/" << cls << ".h>" << endl << endl;
			else
				impl << "#include <Protocol/Packages/" << first_upper(i->first) << "/" << cls << ".h>" << endl << endl;
			impl << "using namespace std;" << endl << endl;
			impl << "namespace Protocol {" << endl;
			impl << "\t" << cls << "::" << cls;
			if (j->second.fields.size() > 0 || j->second.extends_package.size())
				impl << "(const sigset_t &mask, const bool &cancel, size_t &length, DataStream &stream):" << endl;
			else
				impl << "(const sigset_t &, const bool &, size_t &, DataStream &)" << endl;
			if (j->second.extends_package.size()){
				impl << "\t\t" << make_class_name(j->second.extends_package) << "Package(mask, cancel, length, stream)";
				if (j->second.fields.size())
					impl << "," << endl;
			}
			impl << endl;
			for (vector<Field>::const_iterator field = j->second.fields.begin(); field != j->second.fields.end(); ++field){
				if (!field->type.compare("package-map")){
					impl << "\t\t" << field->name << "(" << "DataPackageFactory::deserialize_unknown(mask, cancel, length, stream))";
				} else 
					impl << "\t\t" << field->name << "(stream.read_" << to_stream_type(field->type, enums, *field) << "(mask, cancel, length))";
				if ((field + 1) != j->second.fields.end())
					impl << ",";
				impl << endl;
			}
			impl << "\t{" << endl;
			impl << "\t}" << endl << endl;
			
			impl << "\t" << cls << "::" << get_ctor_sig(j->second, enums);
			if (j->second.fields.size() > 0)
				impl << ":" << endl;
			impl << endl;
			for (vector<Field>::const_iterator field = j->second.fields.begin(); field != j->second.fields.end(); ++field){
				impl << "\t\t" << field->name << "(" << field->name << ")";
				if ((field + 1) != j->second.fields.end())
					impl << ",";
				impl << endl;
			}
			impl << "\t{" << endl;
			impl << "\t}" << endl << endl;
			
			if (!j->second.extends_package.size()){
				impl << "\tvoid " << cls << "::" << "serialize(const sigset_t &mask, const bool& cancel, DataStream &stream, bool with_header) const" << endl;
				impl << "\t{" << endl;
				impl << "\t\tif (with_header){" << endl;
				impl << "\t\t\tstream.write_uint8(mask, cancel, get_type());" << endl;
				impl << "\t\t\tstream.write_uint32(mask, cancel, get_ser_size());" << endl;
				impl << "\t\t}" << endl;
				for (vector<Field>::const_iterator field = j->second.fields.begin(); field != j->second.fields.end(); ++field){
					if (!field->type.compare("package-map")){
						impl << "\t\tstream.write_varuint(mask, cancel, VarUint(" << field->name << "->get_type(), false));" << endl;
						impl << "\t\t" << field->name << "->serialize(mask, cancel, stream, false);" << endl;
					} else
						impl << "\t\tstream.write_" << to_stream_type(field->type, enums, *field) << "(mask, cancel, " << field->name << ");" << endl;
				}
				impl << "\t}" << endl << endl;
			}
			
			impl << "\tuint8_t " << cls << "::get_type() const" << endl;
			impl << "\t{" << endl;
			impl << "\t\treturn " << make_upper(j->first) << "_PACKAGE;" << endl;
			impl << "\t}" << endl << endl;

			if (!j->second.extends_package.size()){
				impl << "\tstring " << cls << "::to_string() const" << endl;
				impl << "\t{" << endl;
				impl << "\t\tstringstream ss;" << endl;
				impl << "\t\tss << \"" << cls << ":\" << endl;" << endl;
				for (vector<Field>::const_iterator field = j->second.fields.begin(); field != j->second.fields.end(); ++field){
					impl << "\t\tss << \"  "<< field->name << ": \" << " << get_to_string_impl(field->name, field->type) << " << endl;" << endl;
				}
				impl << "\t\treturn ss.str();" << endl;
				impl << "\t}" << endl << endl;

				impl << "\tsize_t " << cls << "::get_ser_size() const" << endl;
				impl << "\t{" << endl;
				impl << "\t\treturn 0";
				for (vector<Field>::const_iterator field = j->second.fields.begin(); field != j->second.fields.end(); ++field){
					impl << " + " << get_size(field->name, field->type, enums, field->object_ref);
				}
				impl << ";" << endl;
				impl << "\t}" << endl << endl;
			}

			for (vector<Field>::const_iterator k = j->second.fields.begin(); k != j->second.fields.end(); ++k){
				if (is_object(k->type))
					impl << "\tconst " << to_raw_C_type(k->type) << " &" << cls << "::get_val_" << k->name << "() const" << endl;
				else
					impl << "\t" << to_C_type(k->type, enums, *k) << " " << cls << "::get_val_" << k->name << "() const" << endl;
				impl << "\t{" << endl;
				if (is_object(k->type))
					impl << "\t\treturn *" << k->name << ".get();" << endl;
				else
					impl << "\t\treturn " << k->name << ";" << endl;
				impl << "\t}" << endl;
			}

			impl << "}" << endl;
		}
	}
}

void generate_enums(const vector<Enum> &enums, const vector<pair<string, map<string, Package> > > &package_groups)
{
	cout << "Generating enums" << endl;
	cout << " Generating enum enums" << endl;
	ofstream all((target_dir + "/Enums/Enums.h").c_str());
	if (!all.is_open()){
		cout << "  !!! Processing enums failed on creating files" << endl;
		exit(1);
	}
	all << "#ifndef PROTOCOL_ENUMS_H" << endl;
	all << "#define PROTOCOL_ENUMS_H" << endl << endl;
	all << notice << endl << endl;
	for (vector<Enum>::const_iterator en = enums.begin(); en != enums.end(); ++en){
		cout << " Generating enum " << en->name << endl;
		string enum_name = make_class_name(en->name);
		string f_name = target_dir + "/Enums/" + enum_name + ".h";
		all << "#include <Protocol/Enums/" + enum_name + ".h>" << endl;
		ofstream impl((f_name).c_str());
		if (!impl.is_open()){
			cout << "   !!!Processiong enum " + en->name + " failed (couldn't create files)" << endl;
			exit(1);
		}
		string guard = "PROTOCOL_" + make_upper(en->name) + "_H";
		impl << "#ifndef " << guard << endl;
		impl << "#define " << guard << endl;
		impl << notice << endl << endl;
		impl << "namespace Protocol {" << endl;
		impl << "\tenum " << enum_name << " {" << endl;
		for (vector<EnumItem>::const_iterator item = en->items.begin(); item != en->items.end(); ++item){
			impl << "\t\t" << make_upper(item->name) << " = " << item->value;
			if ((item + 1) != en->items.end())
				impl << ",";
			impl << endl;
		}
		impl << "\t};" << endl;
		impl << "}" << endl;
		impl << "#endif /*" << guard << "*/" << endl;
	}

	for (vector<pair<string, map<string, Package> > >::const_iterator i = package_groups.begin(); i != package_groups.end(); ++i){
		cout << " Generating enum packages" << endl;
		ofstream pkgs((target_dir + "/Enums/" + first_upper(i->first) + "Packages.h").c_str());
		if (!pkgs.is_open()){
			cout << "  !!! Processing enums failed on creating file Packages.h" << endl;
			exit(1);
		}
		pkgs << "#ifndef PROTOCOL_" + make_upper(i->first) + "_PACKAGES_H" << endl;
		pkgs << "#define PROTOCOL_" + make_upper(i->first) + "_PACKAGES_H" << endl << endl;
		pkgs << notice << endl << endl;
		pkgs << "namespace Protocol {" << endl;
		pkgs << "\tenum " + first_upper(i->first) + "Packages {" << endl;

		map<string, Package>::const_iterator j = i->second.begin();
		if (j != i->second.end()){
			pkgs << "\t\t" << make_upper(j->first) << "_PACKAGE = " << j->second.id;
		}
		j++;
		for (; j != i->second.end(); ++j){
			pkgs << "," << endl << "\t\t" << make_upper(j->first) << "_PACKAGE = " << j->second.id;
		}
		pkgs << endl;
		pkgs << "\t};" << endl;
		pkgs << "}" << endl;
		pkgs << "#endif /* PROTOCOL_" + make_upper(i->first) + "_PACKAGES_H */ " << endl;
	}


	for (vector<pair<string, map<string, Package> > >::const_iterator i = package_groups.begin(); i != package_groups.end(); ++i){
		all << "#include <Protocol/Enums/" << first_upper(i->first) << "Packages.h>" << endl << endl;
	}
	all << "#endif /* PROTOCOL_PACKAGES_H */" << endl;
}

void generate_factory(const string &group, const map<string, Package> &packages)
{
	cout << " Generating factory for " << group << endl;
	string cls = first_upper(group) + "PackageFactory";
	ofstream header((target_dir + "/" + cls + ".h").c_str());
	ofstream impl((target_dir + "/" + cls + ".cpp").c_str());
	if (!header.is_open() || !impl.is_open()){
		cout << "  !!! Generating package factories failed on creating files" << endl;
		exit(1);
	}
	string guard = "PROTOCOL_" + make_upper(group) + "_PACKAGE_FACTORY";
	header << "#ifndef " << guard << endl;
	header << "#define " << guard << endl;
	header << notice << endl;
	header << "#include <signal.h>" << endl;
	header << "#include <memory>" << endl;
	header << "#include <Protocol/Streams/DataStream.h>" << endl;
	header << "namespace Protocol{" << endl;
	header << "	class Package;" << endl;
	header << "	class " << cls << " {" << endl;
	header << "		public:" << endl;
	header << "			static std::auto_ptr<Package> deserialize(const sigset_t" << endl;
	header << "					&mask, const bool &cancel, uint8_t id," << endl;
	header << "					size_t &length, DataStream &stream);" << endl;
	header << "			static std::auto_ptr<Package> deserialize_unknown(const sigset_t" << endl;
	header << "					&mask, const bool &cancel," << endl;
	header << "					size_t &length, DataStream &stream);" << endl;
	header << "	};" << endl;
	header << "}" << endl;
	header << "#endif /* " << guard << " */" << endl;

	impl << notice << endl;
	impl << "#include <memory>" << endl;
	impl << "#include <Protocol/Exceptions.h>" << endl;
	impl << "#include <Protocol/" << cls << ".h>" << endl;
	impl << "#include <Protocol/Enums/Enums.h>" << endl;
	for (map<string, Package>::const_iterator package = packages.begin(); package != packages.end(); ++package)
	{
		if (group.size() == 0)
			impl << "#include <Protocol/Packages/" << make_class_name(package->first) << "Package.h>" << endl;
		else
			impl << "#include <Protocol/Packages/" << first_upper(group) << "/" << make_class_name(package->first) << "Package.h>" << endl;
	}
	impl << "#include <Protocol/Packages/WCHelloPackage.h>" << endl;
	impl << "" << endl;
	impl << "namespace Protocol{" << endl;
	impl << "" << endl;
	impl << "	std::auto_ptr<Package> " << cls << "::deserialize(const sigset_t" << endl;
	impl << "			&mask, const bool &cancel, uint8_t id, size_t &length," << endl;
	impl << "			DataStream &stream)" << endl;
	impl << "	{" << endl;
	impl << "		switch (id) {" << endl;
	for (map<string, Package>::const_iterator package = packages.begin(); package != packages.end(); ++package)
	{
		impl << "\t\t\tcase " << make_upper(package->first) << "_PACKAGE: return std::auto_ptr<Package>(new " << make_class_name(package->first) << "Package(mask, cancel, length, stream));" << endl;
	}
	impl << "		    default:throw ProtocolLogic();" << endl;
	impl << "		}" << endl;
	impl << "	}" << endl;
	impl << endl;
	impl << "	std::auto_ptr<Package> " << cls << "::deserialize_unknown(const sigset_t" << endl;
	impl << "			&mask, const bool &cancel, size_t &length," << endl;
	impl << "			DataStream &stream)" << endl;
	impl << "	{" << endl;
	impl << "		uint8_t id = stream.read_uint8(mask, cancel, length);" << endl;
	impl << "		return deserialize(mask, cancel, id, length, stream);" << endl;
	impl << "	}" << endl;
	impl << "}" << endl;
}

void generate_makefiles(const vector<Enum> &enums, const vector<pair<string, map<string, Package> > > &package_groups)
{
	cout << "Generating CMakeLists.txt" << endl;
	cout << " Generating makefiles for packages" << endl;
	string includes = "include_directories(${CMAKE_SOURCE_DIR}/src ${CMAKE_BINARY_DIR}/src ${INCDIR})";
	for (vector<pair<string, map<string, Package> > >::const_iterator package_group = package_groups.begin(); package_group != package_groups.end(); ++package_group) {
		ofstream mk((target_dir + "/Packages/" + first_upper(package_group->first) + "/CMakeLists.txt").c_str());
		mk << notice2 << endl << endl;
		mk << includes << endl;
		if (!mk.is_open()){
			cout << "  !!! Couldn't create CMakeLists !!! " << endl;
			exit(1);
		}

		if (package_group->first.size() == 0 ) {

			for (vector<pair<string, map<string, Package> > >::const_iterator
					package_groupHelp = package_groups.begin();
					package_groupHelp != package_groups.end();
					++package_groupHelp) {
				if (package_groupHelp->first.size() != 0) {
					mk << "add_subdirectory(" << first_upper(package_groupHelp->first) << ")" << endl;
				}
			}

		}

		mk << "set (ProtocolPackages" << first_upper(package_group->first) << "STAT_SRCS" << endl;
		/* adding sources */
		for (map<string, Package>::const_iterator package = package_group->second.begin(); package != package_group->second.end(); ++package) {
			mk << "\t" << make_class_name(package->first) + "Package.h " << endl;
			mk << "\t" << make_class_name(package->first) + "Package.cpp " << endl;
		}
		/* ugly, but I don't have a better idea */
		if (package_group->first.size() == 0)
			mk <<  "\tPackage.h" << endl << "\tPackage.cpp)" << endl;
		if (!package_group->first.compare("data"))
			mk << "\tCollectionPackage.h" << endl << "\tCollectionPackage.cpp)" << endl;

		mk << "add_library(ProtocolPackages" << first_upper(package_group->first) << " STATIC ${ProtocolPackages" <<  first_upper(package_group->first) << "STAT_SRCS})" << endl;

		if (package_group->first.size() != 0) {
			mk << "target_link_libraries(ProtocolPackages" << first_upper(package_group->first) << " Protocol ProtocolStreams)" << endl;
		}

	}
	{
		cout << " Generating CMakeLists.txt for enums" << endl;
		ofstream mk((target_dir + "/Enums/CMakeLists.txt").c_str());
		if (!mk.is_open()){
			cout << "   !!!! Couldn't create makefile for enums" << endl;
			exit(1);
		}
		mk << notice2 << endl << endl;
		mk << includes << endl;
		mk << "set(ProtocolEnums_STAT_SRCS";

		for (vector<Enum>::const_iterator en = enums.begin(); en != enums.end(); ++en) {
			mk << endl << "\t" << make_class_name(en->name) + ".h " ;
		}
		for (vector<pair<string, map<string, Package> > >::const_iterator pg = package_groups.begin(); pg != package_groups.end(); ++pg) {
			mk << endl << "\t" << first_upper(pg->first) + "Packages.h ";
		}
		mk << endl << "dummy.cpp)" << endl;
		mk << "add_library(ProtocolEnums STATIC ${ProtocolEnums_STAT_SRCS}) " << endl;
	}
	{
		cout << " Generating global CMakeLists.txt" << endl;
		ofstream mk((target_dir + "/CMakeLists.txt").c_str());
		if (!mk.is_open()){
			cout << "   !!!! Couldn't create global makefile" << endl;
			exit(1);
		}
		mk << notice2 << endl << endl;
		mk << includes << endl;
		mk << "add_subdirectory(Streams)" << endl;
		mk << "add_subdirectory(Packages)" << endl;
		mk << "add_subdirectory(Enums)" << endl;
		mk << "set(Protocol_STAT_SRCS" << endl;
		mk << "\tExceptions.cpp" << endl;
		mk << "\tExceptions.h" << endl;
		mk << "\tTCPServer.h" << endl;
		mk << "\tTCPServer.cpp" << endl;
		mk << "\tByteBuffer.h" << endl;
		mk << "\tByteBuffer.cpp" << endl;
		for (vector<pair<string, map<string, Package> > >::const_iterator pg = package_groups.begin(); pg != package_groups.end(); ++pg) {
			mk << "\t" << first_upper(pg->first) << "PackageFactory.h " << endl;
			mk << "\t" << first_upper(pg->first) << "PackageFactory.cpp " << endl;
		}
		mk << "\tVarUint.h)" << endl;
		mk << "add_library(Protocol STATIC ${Protocol_STAT_SRCS})" << endl;
		mk << "target_link_libraries(Protocol ";

		for (vector<pair<string, map<string, Package> > >::const_iterator package_group = package_groups.begin(); package_group != package_groups.end(); ++package_group) {
			mk <<  "ProtocolPackages" + first_upper(package_group->first) + " ";
		}
		mk << ")" << endl;
	}
}

	int main (int argc, char* argv[]) {
		if (argc != 3)
			usage(argv[0]);

	target_dir = argv[2];

	XMLPlatformUtils::Initialize();
	XercesDOMParser parser;
	parser.setValidationScheme(XercesDOMParser::Val_Always);
	parser.setDoNamespaces(true);
	parser.setValidationConstraintFatal(true);
	parser.setValidationSchemaFullChecking(true);
	parser.setDoSchema(true);
	parser.setExternalSchemaLocation("http://loxim.mimuw.edu.pl/protoGen protoGen.xsd");
	parser.setLoadSchema(true);
	MyErrorHandler errHandler;
	parser.setErrorHandler(&errHandler);
		

	try {
		parser.parse(argv[1]);
		DOMElement &doc = *parser.getDocument()->getDocumentElement();
		DOMNodeList &nl = *doc.getElementsByTagName(S2X("packet-groups").val());
		assert(nl.getLength() == 1);
		vector<pair<string, map<string, Package> > > package_groups = handle_package_groups(*dynamic_cast<DOMElement*>(nl.item(0)));
		DOMNodeList &nl2 = *doc.getElementsByTagName(S2X("enums").val());
		assert(nl2.getLength() == 1);
		vector<Enum> enums = handle_enums(*dynamic_cast<DOMElement*>(nl2.item(0)));

		for (vector<pair<string, map<string, Package> > >::iterator i = package_groups.begin(); i != package_groups.end(); ++i){
			for (map<string, Package>::iterator j = i->second.begin(); j != i->second.end(); ++j)
				j->second.flatten(package_groups);
		}
		generate_package_headers(package_groups, enums);
		generate_package_implementations(package_groups, enums);
		generate_enums(enums, package_groups);
		cout << "Generating factories" << endl;
		for (vector<pair<string, map<string, Package> > >::const_iterator i = package_groups.begin(); i != package_groups.end(); ++i){
			generate_factory(i->first, i->second);
		}
		generate_makefiles(enums, package_groups);
		cout << "All done :)" << endl;
	}
	catch( XMLException& e )
	{
		cout<< "Error parsing file: " << X2S(e.getMessage()) << endl;
		return 1;
	}
	catch( SAXException& e )
	{
		cout<< "Error parsing file: " << X2S(e.getMessage()) << endl;
		return 1;
	}
	catch( DOMException& e )
	{
		cout<< "Error parsing file: " << X2S(e.getMessage()) << endl;
		return 1;
	}
	return 0;
}

