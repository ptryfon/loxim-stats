Omowic czy data value::vector przechowuje objectPointery czy samo LogicalID
- jesli przechowuje objectPointery to jest problem przy odczycie
  z bazy: dataValue nie ma mozliwosci wywolywania StoreManagera
  nawet gdyby mialo, to takie odczyty nie bylyby synchronizowane (pomijalyby
  pozakladane locki)
- jesli przechowuje LogicalID to ci co uzywaja tego data value musza
  manualnie wywolywac getObject dla kazdego LogicalID z vektora
  i przechowywac na wlasnej strukturze rezultaty
Nalezy rozwazyc inne za i przeciw obu propozycji
Proponowane rozwiazanie na dzien dzisiejszy: drugie


DBDataVaule : Serializable
md  // 1. deserialize() - <- dodac obsluge wektora
mdOK// 2. p_DestroyVal() - <- dodac obsluge pointera i wektora

DBObjectPointer : Serializable
mdOK// 1. ~DBObjectPointer() 
md  // 2. operator==()

DBPhysicalID
??  // 1. getFile()
??  // 2. getPage()
??  // 3. getOffset()

DBStoreManager
md  // 1. getObject() - dokonczyc
md  // 2. createObject() - dokonczyc
tr  // 3. deleteObject() - dokonczyc
??  // 4. getRoots(ALL) - remake + ktos wgral stara wersje sprzed tygodnia
         osoba ta zostanie predzej czy pozniej dopadnieta
??  // 5. getRoots(BYNAME) - remake
??  // 6. addRoot() - remake
??  // 7. removeRoot()

??  // 8. commitTransaction() ?
??  // 9. abortTransaction() ?
??  // 10. createPointerValue()
??  // 11. createVectorValue()

PagePointer
mk  // 1. aquire()


