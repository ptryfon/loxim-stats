prywatne notatki jsi
-----------------------
 (EMP join SAL).SAL									-- nie dzialalo bo
 w sigColl::statnested zwracalem czesciowy wynik a nie koncowy !! 
-----------------------
 testy:
 cat Server/jsi.txt | grep "rmvDeath end, zwraca" -A 1
 
 ./Listener 2>/dev/null | grep "rmvDeath end, zwraca" -A 1
 
 
 (EMP join (WORKS_IN.DEPT)).(NAME, SAL)

 count(((EMP join SAL join NAME join ADDRESS join STREET join NO join WORKS_IN) 
 group as aaa).aaa.DEPT)			nic nie usunal
  count((((EMP join SAL join NAME) join (ADDRESS join STREET join NO) join WORKS_IN) 
  group as aaa).aaa.DEPT)			ladnie pousuwal
 
DEPT{
	DNAME	1..1 string
	LOC		1..* string
}

EMP{
	NAME		1..1 string
	SAL			1..1 int
	WORKS_IN	1..1 ref do DEPT
	
	ADDRESS 0..* {
		STREET	1..1 string
		NO		1..1 int
	}
	PIES	1..1 {
		IMIE	1..1 string
		WIEK	1..1 int
	}
	KOT		1..1 {
		KOLOR	1..1 string
		WIEK	1..1 int
	}
}

-----------------------------------------------------------------------------------------
test parsera - usuwanie martwych podzapytan
W katalogu QueryParser/jsi/ sa pliki
MdnJsi.txt, DaneJsi.txt, test.txt

jak mozna przetestowac:
na czystej bazie 
ustawic w Server.conf optimization=on
@MdnJsi.txt
@DaneJsi.txt
teraz zrestartowac serwer (aby wczytal schemat danych)
./Listener 2>/dev/null | grep "rmvDeath end, zwraca" -A 1
@test.txt

i na konsoli widac do jakiej postaci je przepisuje.


pozdrawiam
jakub sitek



-------------------------------------
opis plikow

MdnJsi.txt - skrypt tworzacy taki schemat danych
DEPT{
	DNAME	1..1 string
	LOC		1..* string
}

EMP{
	NAME		1..1 string
	SAL			1..1 int
	WORKS_IN	1..1 ref do DEPT
	
	ADDRESS 0..* {
		STREET	1..1 string
		NO		1..1 int
	}
	PIES	1..1 {
		IMIE	1..1 string
		WIEK	1..1 int
	}
	KOT		1..1 {
		KOLOR	1..1 string
		WIEK	1..1 int
	}
}
DaneJsi.txt - przykladowe dane do tego schematu
test.txt - przykladowe zapytania z martwymi podzapytaniami:

begin
/

-- usuwa WORKS_IN.DEPT
(EMP join (WORKS_IN.DEPT)).(NAME, SAL)
/

((EMP join DEPT) join (NAME, SAL, DNAME)).DNAME
/

((EMP join DEPT) join (NAME, SAL, DNAME)).NAME
/

-- (nie usuwa ADDRESS bo ma licznosc 0..*) - ok
(EMP join (SAL, NAME, ADDRESS, WORKS_IN)).DEPT   
/

count((EMP join (SAL, NAME, ADDRESS, WORKS_IN)).DEPT) 
/ 

-- usuwa SAL, NAME, oraz STREET i NO - wszystkie maja licznosc 1..1
((EMP join (SAL, NAME, ADDRESS join (STREET, NO), WORKS_IN)) group as aaa).aaa.DEPT
/

((EMP join NAME)  where (SAL = (EMP where NAME = "Jakub" ).SAL) ).ADDRESS
/

end
/

zostaja one zoptymalizowane do takiej postaci:

rmvDeath end, zwraca
((EMP[1,1]0..*depOn:NULL:needed)_ . _0..*Need<2,2>((NAME[2,2]1..1depOn:EMP:needed) , 1..1Need(SAL[2,2]1..1depOn:EMP:needed)))
--
rmvDeath end, zwraca
(((EMP[1,1]0..*depOn:NULL:notNeeded)join0..*Need<2,2>(DEPT[1,2]0..*depOn:NULL:needed))_ . _0..*Need<2,2>(DNAME[2,2]1..1depOn:DEPT:needed))
--
rmvDeath end, zwraca
(((EMP[1,1]0..*depOn:NULL:needed)join0..*Need<2,2>(DEPT[1,2]0..*depOn:NULL:notNeeded))_ . _0..*Need<2,2>(NAME[2,2]1..1depOn:EMP:needed))
--
rmvDeath end, zwraca
(((EMP[1,1]0..*depOn:NULL:needed)join0..*Need<2,2>((ADDRESS[2,2]0..*depOn:EMP:notNeeded) , 0..*Need(WORKS_IN[2,2]1..1depOn:EMP:needed)))_ . _0..*Need<2,2>(DEPT[2,2]1..1depOn:WORKS_IN:needed))
--
rmvDeath end, zwraca
(count(((EMP[1,1]0..*depOn:NULL:needed)join0..*Need<2,2>((ADDRESS[2,2]0..*depOn:EMP:notNeeded) , 0..*Need(WORKS_IN[2,2]1..1depOn:EMP:needed)))_ . _0..*Need<2,2>(DEPT[2,2]1..1depOn:WORKS_IN:needed)))
--
rmvDeath end, zwraca
((((EMP[1,1]0..*depOn:NULL:needed)join0..*Need<2,2>((ADDRESS[2,2]0..*depOn:EMP:notNeeded) , 0..*Need(WORKS_IN[2,2]1..1depOn:EMP:needed))) group as aaa0..*)_ . _0..*Need<2,2>((aaa[2,2]depOn:aaa:notNeeded)_ . _1..*Need<3,3>(DEPT[3,3]1..1depOn:WORKS_IN:needed)))
--
rmvDeath end, zwraca
(((EMP[1,1]0..*depOn:NULL:needed)where0..*Need<2,2>((SAL[2,2]1..1depOn:EMP:notNeeded) = 1..1Del(((EMP[1,2]0..*depOn:NULL:notNeeded)where0..*Del<3,3>((NAME[3,3]1..1depOn:EMP:notNeeded) = 1..1Del(_value_)))_ . _0..*Del<3,3>(SAL[3,3]1..1depOn:EMP:notNeeded))))_ . _0..*Need<2,2>(ADDRESS[2,2]0..*depOn:EMP:needed))

==============================================================================================

(EMP.(NAME group as N, SAL group as S))  where S = (EMP where NAME = "kuba" ).SAL
kwasi?

brak oblugi derefa - zwraca -1 w complex

prztestowac tez na czyms takim emp join (worksin.dept). name ale gdy dzial ma pole name

to statNested(TreeNode * treeNode) to chyba jakas glupota, cyba wystarczy lokalnie sobie
zadekl treeNode = this->dependsOn()
-------------------------------------------


deref(EMP.(SAL, NAME));
/

deref(EMP.(SAL group as S, NAME group as N));
/

deref(EMP join (SAL, NAME));
/

deref(EMP join (SAL join NAME));
/



